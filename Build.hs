{-# LANGUAGE LambdaCase #-}
{-# OPTIONS_GHC -Wall #-}

-- | Fire-and-forget build script to configure the Infinity Ergodox
-- firmware.
--
-- Userland configuration is in "Config.hs".
module Build (main) where



import Data.Foldable
import Data.List (intercalate, isInfixOf)
import Data.Monoid
import System.Console.GetOpt
import System.Exit

import Development.Shake hiding (addPath)
import Development.Shake.FilePath

import Build.Types
import qualified Build.WrappedBuildSystemConfig as Build
import qualified Layout.Config as Layout



pprHalf :: Half -> String
pprHalf = \case
    L -> "left"
    R -> "right"

leftHalf :: Flash -> Rules ()
leftHalf = phonyForHalf L

rightHalf :: Flash -> Rules ()
rightHalf = phonyForHalf R

phonyForHalf :: Half -> Flash -> Rules ()
phonyForHalf half flash = phony (pprHalf half) (do
    need [firmwareFile half]
    installFirmware half flash )



-- | Shake build files output directory
buildPath :: FilePath
buildPath = ".build"

-- | Final location of the firmware
firmwareFile :: Half -> FilePath
firmwareFile half = buildPath </> "ergodox-" <> pprHalf half <.> "dfu.bin"



-- | Compile the firmware a .bin file that can be sent to the keyboard
buildFirmware :: Half -> Rules ()
buildFirmware half = firmwareFile half %> (\out -> do
    moveKlls
    createWrappedBuildPath
    cmake
    make
    extractFirmwareTo out )
  where

    -- Move .kll files to their appropriate target folder so the compilation
    -- script has them in the right locations
    moveKlls :: Action ()
    moveKlls = sequence_ [moveBaseMap, moveDefaultMap, moveLayers]
      where
        moveBaseMap = do
            let BaseMap baseMap = Layout.baseMap half
            for_ baseMap (\kll ->
                let kllFile = kll <.> "kll"
                    src = "Layout" </> kllFile
                    dest = "controller/Scan/MDErgo1" </> kllFile
                in copyFileChanged src dest )
        moveDefaultMap = do
            let DefaultMap defaultMap = Layout.defaultMap
            need ["controller/kll"]
            for_ defaultMap (\kll ->
                let kllFile = kll <.> "kll"
                    src = "Layout" </> kllFile
                    dest = "controller/kll/layouts" </> kllFile
                in copyFileChanged src dest )
        moveLayers = do
            let PartialMaps layers = Layout.partialMaps
            need ["controller/kll"]
            for_ layers (\(Layer layer) ->
                for_ layer (\kll ->
                    let kllFile = kll <.> "kll"
                        src = "Layout" </> kllFile
                        dest = "controller/kll/layouts" </> kllFile
                    in copyFileChanged src dest ))

    createWrappedBuildPath :: Action ()
    createWrappedBuildPath =
        cmd (Traced "Creating inner firmware output dir")
            "mkdir -p" [wrappedBuildPath]

    cmake :: Action ()
    cmake = cmd
        (Cwd wrappedBuildPath)
        (Traced ("Generating " <> pprHalf half <> " makefile"))
        "cmake"
        [ "-DCHIP="         <> chip
        , "-DCOMPILER="     <> compiler
        , "-DScanModule="   <> scanModule
        , "-DMacroModule="  <> macroModule
        , "-DOutputModule=" <> outputModule
        , "-DDebugModule="  <> debugModule
        , "-DBaseMap="      <> baseMap
        , "-DDefaultMap="   <> defaultMap
        , "-DPartialMaps="  <> partialMaps ]
        "../.."
      where
        Chip         chip         = Build.chip
        Compiler     compiler     = Build.compiler
        ScanModule   scanModule   = Build.scanModule
        MacroModule  macroModule  = Build.macroModule
        OutputModule outputModule = Build.outputModule
        DebugModule  debugModule  = Build.debugModule
        baseMap =
            let BaseMap x = Layout.baseMap half
            in unwords x
        defaultMap =
            let DefaultMap x = Layout.defaultMap
            in unwords x
        partialMaps =
            let PartialMaps pms = Layout.partialMaps
                layers = [ unwords layer | Layer layer <- pms]
            in intercalate ";" layers

    make :: Action ()
    make = cmd
        (Cwd wrappedBuildPath)
        (Traced ("Compiling " <> pprHalf half <> " half"))
        "make"

    extractFirmwareTo :: FilePath -> Action ()
    extractFirmwareTo out = copyFileChanged wrappedFirmwareFile out

    -- | Directory the wrapped build system puts its files to
    wrappedBuildPath :: FilePath
    wrappedBuildPath = "controller/build/ergodox-" <> pprHalf half

    -- | Compiled firmware file as generated by the inner firmware
    wrappedFirmwareFile :: FilePath
    wrappedFirmwareFile = wrappedBuildPath </> "kiibohd.dfu.bin"



-- | For some reason, the build system does not have the "kll" repo as a
-- submodule. This rule ensures an initial dummy build is done, during which
-- the "controller" repo sets itself up correctly.
initializeKllDir :: Rules ()
initializeKllDir = "controller/kll" %> \_ -> do
    let dummyPath = "controller/dummy"
    cmd (Traced "Creating dummy output dir")
        "mkdir -p" [dummyPath] // ()
    cmd (Cwd dummyPath) (Traced "Preparing initial dummy build")
        "cmake .."



-- | Send generated .bin firmware to the keyboard. Requires it to be in
-- flashing state.
installFirmware :: Half -> Flash -> Action ()
installFirmware _ NoFlash = putNormal "Flashing skipped (enable with --flash)"
installFirmware half FlashAfterBuild = do
    need [firmwareFile half]
    let (wd, firmware) = splitFileName (firmwareFile half)
    (Exit e, Stderr stderr) <- cmd (Cwd wd) (Traced "Flashing")
        "sudo"
        ["-p", "Root privileges needed to flash uC. Password: "]
        "--"
        "dfu-util"
        ["--download", firmware]
    case e of
        ExitSuccess -> pure ()
        ExitFailure _e | "No DFU capable USB device" `isInfixOf` stderr
            -> fail "No keyboard in flash mode found."
        _else -> fail stderr



-- | Remove all build files by this script and the wrapped "controller" build
-- system.
clean :: Rules ()
clean = phony "clean" (do
    removeFilesAfter ".build" ["//*"]
    putNormal "Cleaning wrapped build systems in controller/"
    gitClean "controller"
    gitClean "controller/kll" )
  where
    gitClean :: FilePath -> Action ()
    gitClean dir =
        cmd (Cwd dir) (Traced "")
            "git clean -df"



-- | Postfix version of 'unit'
(//) :: m () -> a -> m ()
x // _ = unit x
infix 1 //



-- | Should the keyboard be automatically flashed after building finishes?
data Flash = FlashAfterBuild | NoFlash

data Flags = FlashFlag -- ^ Send firmware to the keyboard after building?
    deriving Eq

flagSpecs :: [OptDescr (Either a Flags)]
flagSpecs =
    [Option "" ["flash"] (NoArg (Right FlashFlag)) "Flash keyboard"]



main :: IO ()
main = shakeArgsWith options flagSpecs (\flags targets -> return (Just (
    let rulesFlagged = ruleRecipes (flashFlag flags)
        rules = handleTargets rulesFlagged targets
    in rules )))
  where

    ruleRecipes flash = mconcat [halves flash, firmware, clean, aux]
      where
        halves   = leftHalf <> rightHalf
        firmware = buildFirmware L <> buildFirmware R
        aux      = initializeKllDir

    handleTargets rules [] = rules
    handleTargets rules targets = want targets >> withoutActions rules

    flashFlag flags | FlashFlag `elem` flags = FlashAfterBuild
                    | otherwise              = NoFlash

    options = shakeOptions
